#!/bin/bash
# Comprehensive Oracle to PostgreSQL converter for complex files
# - Convert một số pattern Oracle phổ biến sang PostgreSQL (an toàn)
# - Cảnh báo các cú pháp/hàm Oracle không tương thích để xử lý tay

###############################################
# Hàm check các hàm / cú pháp Oracle
# chưa tương thích / cần xem lại ở PostgreSQL
###############################################
check_oracle_incompat() {
    local file=$1

    echo "----------------------------------------"
    echo "Oracle compatibility check for: $file"
    echo "Các hàm/cú pháp sau nếu xuất hiện thì cần xem lại/convert tay:"
    echo "  - NVL (nếu còn sót), DECODE, TO_DATE, TO_CHAR, TO_TIMESTAMP"
    echo "  - ADD_MONTHS, MONTHS_BETWEEN, LAST_DAY, NEXT_DAY, TRUNC(date)"
    echo "  - ROWNUM, DBMS_*"
    echo "  - TYPE ... IS TABLE OF ... INDEX BY ..."
    echo "  - array.EXISTS(cnt)"
    echo "  - FETCH cursor INTO array[index]"
    echo "  - Outer join kiểu Oracle: ( + )"
    echo "  - NULL() (dùng sai trong PostgreSQL)"
    echo "  - IN OUT / INOUT parameter"
    echo "  - Gọi typeArray() để init (varA := typeArray())"
    echo "  - SQLCODE, SQLERRM(...)"
    echo "  - OID (cần xem lại nếu đang dùng để tham chiếu row)"
    echo "  - Gọi pkprint.insertdata(...) nhưng vẫn truyền từng item lẻ thay vì composite TYPE_SREPORT_WK_ITEM"
    echo "  - l_outSqlCode OUT nên là integer, l_outSqlErrM OUT nên là text"
    echo "  - Cú pháp Oracle array-style: aryXxx(0) → PostgreSQL: aryXxx[1]"
    echo "  - %ISOPEN trên cursor (cần rewrite sang logic IF cursor_var IS OPEN THEN ... hoặc tương đương)"
    echo "  - ROWID / UROWID (cần xem lại, không mapping 1-1 với PostgreSQL)"
    echo

    # Mỗi entry dạng: "LABEL|REGEX"
    local checks=(
        # Hàm / expression Oracle
        "NVL|\\bNVL\\s*\\("
        "DECODE|\\bDECODE\\s*\\("
        "TO_DATE|\\bTO_DATE\\s*\\("
        "TO_CHAR|\\bTO_CHAR\\s*\\("
        "TO_TIMESTAMP|\\bTO_TIMESTAMP\\s*\\("
        "ADD_MONTHS|\\bADD_MONTHS\\s*\\("
        "MONTHS_BETWEEN|\\bMONTHS_BETWEEN\\s*\\("
        "LAST_DAY|\\bLAST_DAY\\s*\\("
        "NEXT_DAY|\\bNEXT_DAY\\s*\\("
        "TRUNC|\\bTRUNC\\s*\\("
        "ROWNUM|\\bROWNUM\\b"
        "DBMS_PACKAGE|\\bDBMS_[A-Z0-9_]+"

        # %ISOPEN trên cursor
        "%ISOPEN_ATTR|%ISOPEN"

        # ROWID / UROWID
        "ROWID_USAGE|\\bROWID\\b|\\bUROWID\\b"

        # Oracle collection kiểu TABLE OF ... INDEX BY ...
        "TABLE_OF_INDEX_BY|TYPE[[:space:]]+[A-Za-z0-9_]+[[:space:]]+IS[[:space:]]+TABLE[[:space:]]+OF"

        # FETCH cursor INTO array[index]
        "FETCH_ARRAY_INTO|\\bFETCH[[:space:]]+[A-Za-z_][A-Za-z0-9_]*[[:space:]]+INTO[[:space:]]+[A-Za-z_][A-Za-z0-9_]*[[:space:]]*\\["

        # array.EXISTS(idx)
        "ARRAY_EXISTS|\\b[A-Za-z_][A-Za-z0-9_]*\\s*\\.EXISTS\\s*\\("

        # Outer join Oracle: (+)
        "OUTER_JOIN_PLUS|\\(\\+\\)"

        # NULL() dùng như hàm
        "NULL_FUNC|\\bNULL\\s*\\("

        # IN OUT / INOUT parameter
        "INOUT_PARAM|\\bIN[[:space:]]+OUT\\b|\\bINOUT\\b"

        # typeArray() init: varA := typeArray()
        "TYPE_INIT_CALL|:=\\s*[A-Za-z_][A-Za-z0-9_]*\\s*\\(\\s*\\)"

        # SQLCODE, SQLERRM
        "SQLCODE_USAGE|\\bSQLCODE\\b"
        "SQLERRM_CALL|\\bSQLERRM\\s*\\("

        # OID usage
        "OID_USAGE|\\boid\\b"
    )

    local has_any=0

    for entry in "${checks[@]}"; do
        local label="${entry%%|*}"
        local regex="${entry#*|}"

        local matches
        # Giảm false positive cho 'SQLCODE:' (string literal)
        if [[ "$label" == "SQLCODE_USAGE" ]]; then
            matches=$(grep -niE "$regex" "$file" 2>/dev/null | grep -vi "'SQLCODE:" || true)
        else
            matches=$(grep -niE "$regex" "$file" 2>/dev/null || true)
        fi

        if [[ -n "$matches" ]]; then
            has_any=1
            echo ">>> [$label] tìm thấy các dòng sau (cần xem lại/convert tay):"
            echo "$matches"
            echo
        fi
    done

    ########################################################
    # Cảnh báo: TYPE_SREPORT_WK_ITEM + pkprint.insertdata
    # → nên truyền composite thay vì từng item lẻ
    ########################################################
    if grep -qi "TYPE_SREPORT_WK_ITEM" "$file"; then
        local insert_calls
        insert_calls=$(grep -niE "pkprint\\s*\\.\\s*insertdata\\s*\\(" "$file" 2>/dev/null || true)

        if [[ -n "$insert_calls" ]]; then
            has_any=1
            echo ">>> [SREPORT_WK_ITEM_COMPOSITE] File có TYPE_SREPORT_WK_ITEM và gọi pkprint.insertdata:"
            echo "    PostgreSQL cần truyền 1 biến composite TYPE_SREPORT_WK_ITEM"
            echo "    thay vì từng tham số lẻ l_inItem001, l_inItem002, ..."
            echo "$insert_calls"
            echo
        fi
    fi

    ########################################################
    # Cảnh báo: Kiểu OUT parameter
    #  - l_outSqlCode OUT phải là integer
    #  - l_outSqlErrM OUT phải là text
    ########################################################
    local wrong_out_sqlcode
    wrong_out_sqlcode=$(grep -niE "l_outSqlCode[[:space:]]+OUT[[:space:]]+[A-Za-z0-9_]+" "$file" 2>/dev/null | grep -vi "integer" || true)
    if [[ -n "$wrong_out_sqlcode" ]]; then
        has_any=1
        echo ">>> [OUT_PARAM_TYPE] l_outSqlCode OUT không phải integer, cần chỉnh lại:"
        echo "$wrong_out_sqlcode"
        echo
    fi

    local wrong_out_sqlerrm
    wrong_out_sqlerrm=$(grep -niE "l_outSqlErrM[[:space:]]+OUT[[:space:]]+[A-Za-z0-9_]+" "$file" 2>/dev/null | grep -vi "text" || true)
    if [[ -n "$wrong_out_sqlerrm" ]]; then
        has_any=1
        echo ">>> [OUT_PARAM_TYPE] l_outSqlErrM OUT không phải text, cần chỉnh lại:"
        echo "$wrong_out_sqlerrm"
        echo
    fi

    ########################################################
    # Cảnh báo: Oracle array-style access (aryXxx(0) ...)
    # - Heuristic: tên biến có prefix ary/arr/tab/list/tbl/vec + "("
    # - Loại bỏ các dòng định nghĩa/gọi function phổ biến
    ########################################################
    local array_calls
    array_calls=$(grep -niE '\b(ary|arr|tab|list|tbl|vec)[A-Za-z0-9_]*[[:space:]]*\(' "$file" 2>/dev/null \
        | grep -viE 'CREATE[[:space:]]+FUNCTION|FUNCTION[[:space:]]+[A-Za-z_]|CALL[[:space:]]|PERFORM[[:space:]]|SELECT[[:space:]]+[A-Za-z0-9_]+[[:space:]]*\(' \
        || true)

    if [[ -n "$array_calls" ]]; then
        has_any=1
        echo ">>> [ORACLE_ARRAY_ACCESS] Phát hiện cú pháp Oracle array-style (ví dụ: aryBun(0)):"
        echo "    PostgreSQL dùng cú pháp mảng: aryBun[1] thay vì aryBun(0)"
        echo "    (mảng trong PostgreSQL bắt đầu từ 1, không phải 0)"
        echo "$array_calls"
        echo
    fi

    if [[ $has_any -eq 0 ]]; then
        echo "Không phát hiện hàm/cú pháp Oracle 'nhạy cảm' trong danh sách check ở trên."
    fi

    echo "----------------------------------------"
    echo
}


convert_complex_file() {
    local file=$1

    echo "Converting: $file"

    #################################################################
    # Step 0: Fix invalid comment syntax " */;" (Oracle -> Postgres)
    #################################################################
    sed -i 's/ \*\/;$//' "$file"

    #################################################################
    # Step 1: Basic signature conversion (function header)
    #   FUNCTION xxx (...) RETURN NUMBER IS
    # -> RETURNS NUMERIC LANGUAGE plpgsql AS $body$
    #################################################################
    sed -i 's/RETURN NUMBER IS$/RETURNS NUMERIC LANGUAGE plpgsql AS $body$/g' "$file"
    sed -i 's/RETURN VARCHAR IS$/RETURNS VARCHAR LANGUAGE plpgsql AS $body$/g' "$file"

    #################################################################
    # Step 2: Add DECLARE after function signature
    #################################################################
    sed -i '/^RETURNS.*LANGUAGE plpgsql AS \$body\$$/a\DECLARE' "$file"

    #################################################################
    # Step 3: Type conversions (Oracle -> PostgreSQL)
    #################################################################
    # Chuỗi
    sed -i 's/\bVARCHAR2\b/VARCHAR/g' "$file"
    sed -i 's/\bNVARCHAR2\b/VARCHAR/g' "$file"

    # CHAR(n) giữ nguyên, CHAR không độ dài -> TEXT
    sed -i -E 's/\bCHAR\s*\(([0-9]+)\)/__ORACLE_CHAR__\1__/g' "$file"
    sed -i -E 's/\bCHAR\b/TEXT/g' "$file"
    sed -i -E 's/__ORACLE_CHAR__([0-9]+)__/CHAR(\1)/g' "$file"

    # Số
    sed -i 's/\bNUMBER\b/NUMERIC/g' "$file"
    sed -i 's/\bINTEGER(\([0-9]*\))/INTEGER/g' "$file"

    # CLOB / LONG -> TEXT
    sed -i 's/\bCLOB\b/TEXT/g' "$file"
    sed -i 's/\bLONG\b/TEXT/g' "$file"

    # Binary types
    sed -i 's/\bBLOB\b/BYTEA/g' "$file"
    sed -i -E 's/\bRAW\s*\(\s*[0-9]+\s*\)/BYTEA/g' "$file"
    sed -i 's/\bRAW\b/BYTEA/g' "$file"

    
    #################################################################
    # Step 4: NVL -> COALESCE (chỉ cho pattern chuẩn NVL(...))
    #################################################################
    sed -i 's/\bNVL(/COALESCE(/g' "$file"

    #################################################################
    # Step 4b: collection COUNT: arr.COUNT -> COALESCE(cardinality(arr), 0)
    #################################################################
    sed -i 's/\b\([A-Za-z_][A-Za-z0-9_]*\)\.COUNT\b/COALESCE(cardinality(\1), 0)/g' "$file"

    #################################################################
    # Step 5: PKLOG.ERROR(...) -> CALL PKLOG.ERROR(...)
    #################################################################
    sed -i 's/\bPKLOG\./CALL PKLOG./g' "$file"

    #################################################################
    # Step 6: REF CURSOR -> REFCURSOR (thô, cần review thêm)
    #################################################################
    sed -i '/TYPE.*IS REF CURSOR;/d' "$file"
    sed -i 's/\([a-zA-Z_][a-zA-Z0-9_]*\)\s*CURSOR_TYPE;/\1 REFCURSOR;/g' "$file"

    #################################################################
    # Step 6b: Remove alias from UPDATE target table
    #   UPDATE my_table t SET ... -> UPDATE my_table SET ...
    # (DELETE giữ nguyên)
    #################################################################
    sed -i -E 's/^(UPDATE[[:space:]]+(ONLY[[:space:]]+)?)([A-Za-z0-9_".]+)[[:space:]]+[A-Za-z0-9_"]+/\1\3/' "$file"

    #################################################################
    # Step 7: SQLERRM(SQLCODE) -> SQLERRM (safe auto-convert)
    #################################################################
    sed -i 's/SQLERRM\s*(\s*SQLCODE\s*)/SQLERRM/g' "$file"

    #################################################################
    # Step 8: Oracle block terminator "/" -> $body$;
    #################################################################
    sed -i 's/^\/$/$body$;/' "$file"

    echo "Basic conversion complete for: $file"

    ########################################################
    # Cảnh báo: RAISE NOTICE chưa được comment (--)
    ########################################################
    local uncomm_notices
    uncomm_notices=$(grep -ni "RAISE NOTICE" "$file" 2>/dev/null | grep -vE "^[[:space:]]*--|--[[:space:]]*RAISE" || true)
    if [[ -n "$uncomm_notices" ]]; then
        has_any=1
        echo ">>> [UNCOMMENTED_NOTICE] Phát hiện RAISE NOTICE chưa được comment (--)"
        echo "    PostgreSQL nên comment hoặc loại bỏ khi release chính thức."
        echo "$uncomm_notices"
        echo
    fi

    ########################################################
    # Cảnh báo: Gọi pkPrint.insertData mà chưa có khai báo
    #           v_item TYPE_SREPORT_WK_ITEM;
    ########################################################
    local has_insert
    has_insert=$(grep -qi "pkprint\.insertdata" "$file" && echo 1 || echo 0)
    local has_decl
    has_decl=$(grep -qi "v_item[[:space:]]\+TYPE_SREPORT_WK_ITEM" "$file" && echo 1 || echo 0)
    if [[ $has_insert -eq 1 && $has_decl -eq 0 ]]; then
        has_any=1
        echo ">>> [PKPRINT_ITEM_DECLARATION] Có pkPrint.insertData() nhưng chưa khai báo v_item TYPE_SREPORT_WK_ITEM;"
        echo "    → Cần thêm dòng: v_item TYPE_SREPORT_WK_ITEM;"
        grep -ni "pkprint\\.insertdata" "$file" 2>/dev/null || true
        echo
    fi

    #####################################################
    # Chạy check cảnh báo các chỗ Oracle-style còn lại
    #####################################################
    check_oracle_incompat "$file"
}

# Main
if [ $# -eq 0 ]; then
    echo "Usage: $0 <file1.sql> [file2.sql ...]"
    exit 1
fi

for file in "$@"; do
    if [ -f "$file" ]; then
        convert_complex_file "$file"
    else
        echo "File not found: $file"
    fi
done

echo "Conversion complete!"
